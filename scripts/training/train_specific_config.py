"""
üöÄ Scripts de Treinamento Espec√≠ficos
Comandos prontos para diferentes cen√°rios de treinamento.
"""

from src.yolo.trainer import YOLOTrainer
from src.yolo.config import YOLOConfig, TrainingConfig
from src.yolo.presets import yolo_presets
from loguru import logger
import argparse
from pathlib import Path
from typing import Dict, Any
import sys

# Adicionar src ao path
ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(ROOT))


def create_training_commands() -> Dict[str, Dict[str, Any]]:
    """Cria comandos espec√≠ficos para cada cen√°rio."""
    commands = {
        # Treinamentos r√°pidos para teste
        'quick_test': {
            'description': 'Teste r√°pido (10 √©pocas) - Para validar pipeline',
            'preset': 'detect_nano',
            'overrides': {
                'epochs': 10,
                'batch': 8,
                'patience': 5,
                'name': 'quick_test'
            }
        },

        # Treinamentos de desenvolvimento
        'dev_detect': {
            'description': 'Desenvolvimento - Detec√ß√£o (YOLOv8s, 50 √©pocas)',
            'preset': 'detect_small',
            'overrides': {
                'epochs': 50,
                'patience': 20,
                'name': 'dev_detect'
            }
        },

        'dev_segment': {
            'description': 'Desenvolvimento - Segmenta√ß√£o (YOLOv8s-seg, 50 √©pocas)',
            'preset': 'segment_small',
            'overrides': {
                'epochs': 50,
                'patience': 20,
                'name': 'dev_segment'
            }
        },

        # Treinamentos finais para o TCC
        'final_nano_detect': {
            'description': 'FINAL TCC - YOLOv8n Detec√ß√£o (120 √©pocas)',
            'preset': 'detect_nano',
            'overrides': {
                'epochs': 120,
                'patience': 50,
                'name': 'final_yolov8n_detect',
                'project': 'experiments/final_tcc'
            }
        },

        'final_small_detect': {
            'description': 'FINAL TCC - YOLOv8s Detec√ß√£o (120 √©pocas)',
            'preset': 'detect_small',
            'overrides': {
                'epochs': 120,
                'patience': 50,
                'name': 'final_yolov8s_detect',
                'project': 'experiments/final_tcc'
            }
        },

        'final_medium_detect': {
            'description': 'FINAL TCC - YOLOv8m Detec√ß√£o (150 √©pocas)',
            'preset': 'detect_medium',
            'overrides': {
                'epochs': 150,
                'patience': 50,
                'name': 'final_yolov8m_detect',
                'project': 'experiments/final_tcc'
            }
        },

        'final_small_segment': {
            'description': 'FINAL TCC - YOLOv8s Segmenta√ß√£o (120 √©pocas)',
            'preset': 'segment_small',
            'overrides': {
                'epochs': 120,
                'patience': 50,
                'name': 'final_yolov8s_segment',
                'project': 'experiments/final_tcc'
            }
        },

        # Treinamentos de compara√ß√£o
        'compare_nano': {
            'description': 'COMPARA√á√ÉO - YOLOv8n (100 √©pocas, configura√ß√£o otimizada)',
            'preset': 'detect_nano',
            'overrides': {
                'epochs': 100,
                'batch': 16,  # Batch maior para nano
                'patience': 40,
                'name': 'compare_yolov8n',
                'project': 'experiments/comparison'
            }
        },

        'compare_small': {
            'description': 'COMPARA√á√ÉO - YOLOv8s (100 √©pocas, configura√ß√£o otimizada)',
            'preset': 'detect_small',
            'overrides': {
                'epochs': 100,
                'patience': 40,
                'name': 'compare_yolov8s',
                'project': 'experiments/comparison'
            }
        },

        'compare_medium': {
            'description': 'COMPARA√á√ÉO - YOLOv8m (100 √©pocas, configura√ß√£o otimizada)',
            'preset': 'detect_medium',
            'overrides': {
                'epochs': 100,
                'patience': 40,
                'name': 'compare_yolov8m',
                'project': 'experiments/comparison'
            }
        },

        # Treinamentos experimentais
        'exp_high_aug': {
            'description': 'EXPERIMENTO - Augmentation alta (YOLOv8s)',
            'preset': 'detect_small',
            'overrides': {
                'epochs': 80,
                'patience': 30,
                'name': 'exp_high_augmentation',
                'project': 'experiments/augmentation',
                # Augmentations mais agressivas ser√£o definidas no preset
            }
        },

        'exp_large_batch': {
            'description': 'EXPERIMENTO - Batch grande (YOLOv8s)',
            'preset': 'detect_small',
            'overrides': {
                'epochs': 80,
                'batch': 32,
                'lr0': 0.02,  # LR maior para batch maior
                'patience': 30,
                'name': 'exp_large_batch',
                'project': 'experiments/batch_size'
            }
        },

        # Treinamentos especiais
        'overnight': {
            'description': 'OVERNIGHT - Treinamento longo (YOLOv8m, 200 √©pocas)',
            'preset': 'detect_medium',
            'overrides': {
                'epochs': 200,
                'patience': 80,
                'save_period': 20,  # Salvar a cada 20 √©pocas
                'name': 'overnight_training',
                'project': 'experiments/long_training'
            }
        },

        'resume_training': {
            'description': 'RESUMIR - Continuar treinamento anterior',
            'preset': 'detect_small',
            'overrides': {
                'epochs': 50,  # √âpocas adicionais
                'patience': 25,
                'name': 'resumed_training'
            }
        }
    }

    return commands


def parse_arguments():
    """Parse argumentos da linha de comando."""
    commands = create_training_commands()

    parser = argparse.ArgumentParser(
        description="Scripts espec√≠ficos de treinamento YOLO",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Comandos dispon√≠veis:
{chr(10).join([f"  {name}: {info['description']}" for name, info in commands.items()])}

Exemplos:
  python scripts/train_specific.py quick_test --data data/processed/v1_detect
  python scripts/train_specific.py final_small_detect --data data/processed/v1_detect
  python scripts/train_specific.py compare_nano --data data/processed/v1_detect --device cpu
        """
    )

    parser.add_argument(
        'command',
        choices=list(commands.keys()),
        help='Comando de treinamento espec√≠fico'
    )

    parser.add_argument(
        '--data',
        type=str,
        required=True,
        help='Caminho do dataset processado'
    )

    parser.add_argument(
        '--device',
        type=str,
        default='0',
        help='Dispositivo (0, cpu, etc.)'
    )

    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Mostrar configura√ß√£o sem treinar'
    )

    parser.add_argument(
        '--resume',
        type=str,
        help='Caminho do checkpoint para resumir treinamento'
    )

    # Overrides opcionais
    parser.add_argument('--epochs', type=int,
                        help='Sobrescrever n√∫mero de √©pocas')
    parser.add_argument('--batch', type=int, help='Sobrescrever batch size')
    parser.add_argument('--lr0', type=float,
                        help='Sobrescrever learning rate inicial')
    parser.add_argument('--patience', type=int, help='Sobrescrever patience')
    parser.add_argument('--name', type=str,
                        help='Sobrescrever nome do experimento')

    return parser.parse_args()


def create_config_from_command(command_name: str, args) -> YOLOConfig:
    """Cria configura√ß√£o YOLO baseada no comando."""
    commands = create_training_commands()
    command_info = commands[command_name]

    # Obter preset base
    preset_name = command_info['preset']
    base_config = yolo_presets.get_preset(preset_name)

    # Aplicar overrides do comando
    overrides = command_info['overrides'].copy()

    # Aplicar overrides dos argumentos da linha de comando
    arg_overrides = {}
    for key in ['epochs', 'batch', 'lr0', 'patience', 'name']:
        value = getattr(args, key, None)
        if value is not None:
            arg_overrides[key] = value

    overrides.update(arg_overrides)

    # Sempre sobrescrever device e data
    overrides['device'] = args.device
    overrides['data'] = args.data

    # Separar par√¢metros de treinamento dos de infer√™ncia
    training_params = {**base_config}
    inference_params = {}

    # Extrair par√¢metros de infer√™ncia se existirem
    if 'inference_params' in training_params:
        inference_params = training_params.pop('inference_params')

    # Aplicar overrides aos par√¢metros de treinamento
    training_params.update(overrides)

    # Criar configura√ß√£o
    training_config = TrainingConfig(**training_params)

    # Criar YOLOConfig com par√¢metros de infer√™ncia se existirem
    yolo_config_params = {'training': training_config}
    if 'conf' in inference_params:
        yolo_config_params['conf_threshold'] = inference_params['conf']
    if 'iou' in inference_params:
        yolo_config_params['iou_threshold'] = inference_params['iou']
    if 'max_det' in inference_params:
        yolo_config_params['max_detections'] = inference_params['max_det']

    yolo_config = YOLOConfig(**yolo_config_params)

    return yolo_config


def show_config_preview(config: YOLOConfig, command_name: str):
    """Mostra preview da configura√ß√£o."""
    commands = create_training_commands()
    command_info = commands[command_name]

    tc = config.training

    logger.info(f"üöÄ COMANDO: {command_name}")
    logger.info(f"üìù Descri√ß√£o: {command_info['description']}")
    logger.info("=" * 60)

    logger.info(f"ü§ñ Modelo: {tc.model}")
    logger.info(f"üìä Dataset: {tc.data}")
    logger.info(f"üîÑ √âpocas: {tc.epochs}")
    logger.info(f"üì¶ Batch: {tc.batch}")
    logger.info(f"üíª Dispositivo: {tc.device}")
    logger.info(f"üìê Imagem: {tc.imgsz}px")
    logger.info(f"‚è∞ Patience: {tc.patience}")
    logger.info(f"üíæ Cache: {'‚úÖ' if tc.cache else '‚ùå'}")
    logger.info(f"üé® Augmentation: {'‚úÖ' if tc.augmentation.enabled else '‚ùå'}")

    logger.info(f"\nüß† LEARNING RATE:")
    logger.info(f"  ‚Ä¢ Inicial: {tc.lr0}")
    logger.info(f"  ‚Ä¢ Final: {tc.lrf}")
    logger.info(f"  ‚Ä¢ Momentum: {tc.momentum}")

    logger.info(f"\nüìÅ SA√çDA:")
    logger.info(f"  ‚Ä¢ Projeto: {tc.project}")
    logger.info(f"  ‚Ä¢ Nome: {tc.name}")

    # Estimar tempo se poss√≠vel
    try:
        dataset_path = Path(tc.data)
        if dataset_path.exists():
            train_images_dir = dataset_path / "train" / "images"
            if train_images_dir.exists():
                num_images = len(list(train_images_dir.glob(
                    "*.jpg")) + list(train_images_dir.glob("*.png")))
                estimates = yolo_presets.get_training_estimates(
                    command_info['preset'], num_images)

                logger.info(f"\n‚è±Ô∏è ESTIMATIVAS:")
                logger.info(f"  ‚Ä¢ Imagens: {num_images}")
                logger.info(
                    f"  ‚Ä¢ Tempo total: {estimates['estimated_completion']}")
                logger.info(
                    f"  ‚Ä¢ Tempo/√©poca: {estimates['time_per_epoch_minutes']:.1f}min")
                logger.info(
                    f"  ‚Ä¢ Mem√≥ria: ~{estimates['estimated_memory_gb']:.1f}GB")
    except Exception as e:
        logger.debug(f"Erro calculando estimativas: {e}")


def main():
    """Fun√ß√£o principal."""
    args = parse_arguments()

    logger.info("üöÄ TREINAMENTO ESPEC√çFICO YOLO")
    logger.info("=" * 50)

    try:
        # Criar configura√ß√£o
        config = create_config_from_command(args.command, args)

        # Mostrar preview
        show_config_preview(config, args.command)

        if args.dry_run:
            logger.info(
                "\nüß™ DRY-RUN - Configura√ß√£o criada, mas treinamento n√£o iniciado")
            return

        # Confirmar se n√£o for teste r√°pido
        if args.command != 'quick_test':
            response = input(
                f"\n‚ùì Iniciar treinamento '{args.command}'? [y/N]: ")
            if response.lower() not in ['y', 'yes']:
                logger.info("‚ùå Treinamento cancelado pelo usu√°rio")
                return

        # Iniciar treinamento
        logger.info(f"\nüèãÔ∏è Iniciando treinamento: {args.command}")

        trainer = YOLOTrainer(config)

        if args.resume:
            logger.info(f"üîÑ Resumindo treinamento de: {args.resume}")
            metrics = trainer.resume_training(args.resume)
        else:
            metrics = trainer.train(args.data)

        # Mostrar resultados
        logger.success("üéâ TREINAMENTO CONCLU√çDO!")
        logger.info(f"üìä Melhor mAP50: {metrics.best_map50:.3f}")
        logger.info(f"‚è±Ô∏è  Dura√ß√£o: {metrics.duration}")

        # Salvar comando para refer√™ncia
        commands_log = Path("experiments") / "completed_trainings.txt"
        commands_log.parent.mkdir(exist_ok=True)

        with open(commands_log, 'a') as f:
            f.write(
                f"\n{args.command} - mAP50: {metrics.best_map50:.3f} - {metrics.duration}\n")
            f.write(f"  Dataset: {args.data}\n")
            f.write(f"  Device: {args.device}\n")

    except KeyboardInterrupt:
        logger.warning("‚ö†Ô∏è Treinamento interrompido pelo usu√°rio")
    except Exception as e:
        logger.error(f"‚ùå Erro no treinamento: {str(e)}")
        raise


if __name__ == "__main__":
    main()
